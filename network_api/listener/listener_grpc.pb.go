// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: proto/listener.proto

package listenerpb

import (
	context "context"
	response "github.com/Yeah114/tempest-core/network_api/response"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ListenerService_ListenFateArk_FullMethodName          = "/fateark.proto.listener.ListenerService/ListenFateArk"
	ListenerService_ListenPackets_FullMethodName          = "/fateark.proto.listener.ListenerService/ListenPackets"
	ListenerService_ListenBytesPackets_FullMethodName     = "/fateark.proto.listener.ListenerService/ListenBytesPackets"
	ListenerService_ListenTypedPacket_FullMethodName      = "/fateark.proto.listener.ListenerService/ListenTypedPacket"
	ListenerService_ListenTypedBytesPacket_FullMethodName = "/fateark.proto.listener.ListenerService/ListenTypedBytesPacket"
	ListenerService_ListenPlayerChange_FullMethodName     = "/fateark.proto.listener.ListenerService/ListenPlayerChange"
	ListenerService_ListenChat_FullMethodName             = "/fateark.proto.listener.ListenerService/ListenChat"
	ListenerService_ListenCommandBlock_FullMethodName     = "/fateark.proto.listener.ListenerService/ListenCommandBlock"
)

// ListenerServiceClient is the client API for ListenerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ListenerServiceClient interface {
	ListenFateArk(ctx context.Context, in *ListenFateArkRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Output], error)
	ListenPackets(ctx context.Context, in *ListenPacketsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Packet], error)
	ListenBytesPackets(ctx context.Context, in *ListenBytesPacketsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BytesPacket], error)
	ListenTypedPacket(ctx context.Context, in *ListenTypedPacketRequest, opts ...grpc.CallOption) (*response.GeneralResponse, error)
	ListenTypedBytesPacket(ctx context.Context, in *ListenTypedBytesPacketRequest, opts ...grpc.CallOption) (*response.GeneralResponse, error)
	ListenPlayerChange(ctx context.Context, in *ListenPlayerChangeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PlayerAction], error)
	ListenChat(ctx context.Context, in *ListenChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Chat], error)
	ListenCommandBlock(ctx context.Context, in *ListenCommandBlockRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Chat], error)
}

type listenerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewListenerServiceClient(cc grpc.ClientConnInterface) ListenerServiceClient {
	return &listenerServiceClient{cc}
}

func (c *listenerServiceClient) ListenFateArk(ctx context.Context, in *ListenFateArkRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Output], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ListenerService_ServiceDesc.Streams[0], ListenerService_ListenFateArk_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListenFateArkRequest, Output]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenFateArkClient = grpc.ServerStreamingClient[Output]

func (c *listenerServiceClient) ListenPackets(ctx context.Context, in *ListenPacketsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Packet], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ListenerService_ServiceDesc.Streams[1], ListenerService_ListenPackets_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListenPacketsRequest, Packet]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenPacketsClient = grpc.ServerStreamingClient[Packet]

func (c *listenerServiceClient) ListenBytesPackets(ctx context.Context, in *ListenBytesPacketsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BytesPacket], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ListenerService_ServiceDesc.Streams[2], ListenerService_ListenBytesPackets_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListenBytesPacketsRequest, BytesPacket]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenBytesPacketsClient = grpc.ServerStreamingClient[BytesPacket]

func (c *listenerServiceClient) ListenTypedPacket(ctx context.Context, in *ListenTypedPacketRequest, opts ...grpc.CallOption) (*response.GeneralResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(response.GeneralResponse)
	err := c.cc.Invoke(ctx, ListenerService_ListenTypedPacket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerServiceClient) ListenTypedBytesPacket(ctx context.Context, in *ListenTypedBytesPacketRequest, opts ...grpc.CallOption) (*response.GeneralResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(response.GeneralResponse)
	err := c.cc.Invoke(ctx, ListenerService_ListenTypedBytesPacket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *listenerServiceClient) ListenPlayerChange(ctx context.Context, in *ListenPlayerChangeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PlayerAction], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ListenerService_ServiceDesc.Streams[3], ListenerService_ListenPlayerChange_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListenPlayerChangeRequest, PlayerAction]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenPlayerChangeClient = grpc.ServerStreamingClient[PlayerAction]

func (c *listenerServiceClient) ListenChat(ctx context.Context, in *ListenChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Chat], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ListenerService_ServiceDesc.Streams[4], ListenerService_ListenChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListenChatRequest, Chat]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenChatClient = grpc.ServerStreamingClient[Chat]

func (c *listenerServiceClient) ListenCommandBlock(ctx context.Context, in *ListenCommandBlockRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Chat], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ListenerService_ServiceDesc.Streams[5], ListenerService_ListenCommandBlock_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListenCommandBlockRequest, Chat]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenCommandBlockClient = grpc.ServerStreamingClient[Chat]

// ListenerServiceServer is the server API for ListenerService service.
// All implementations must embed UnimplementedListenerServiceServer
// for forward compatibility.
type ListenerServiceServer interface {
	ListenFateArk(*ListenFateArkRequest, grpc.ServerStreamingServer[Output]) error
	ListenPackets(*ListenPacketsRequest, grpc.ServerStreamingServer[Packet]) error
	ListenBytesPackets(*ListenBytesPacketsRequest, grpc.ServerStreamingServer[BytesPacket]) error
	ListenTypedPacket(context.Context, *ListenTypedPacketRequest) (*response.GeneralResponse, error)
	ListenTypedBytesPacket(context.Context, *ListenTypedBytesPacketRequest) (*response.GeneralResponse, error)
	ListenPlayerChange(*ListenPlayerChangeRequest, grpc.ServerStreamingServer[PlayerAction]) error
	ListenChat(*ListenChatRequest, grpc.ServerStreamingServer[Chat]) error
	ListenCommandBlock(*ListenCommandBlockRequest, grpc.ServerStreamingServer[Chat]) error
	mustEmbedUnimplementedListenerServiceServer()
}

// UnimplementedListenerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedListenerServiceServer struct{}

func (UnimplementedListenerServiceServer) ListenFateArk(*ListenFateArkRequest, grpc.ServerStreamingServer[Output]) error {
	return status.Errorf(codes.Unimplemented, "method ListenFateArk not implemented")
}
func (UnimplementedListenerServiceServer) ListenPackets(*ListenPacketsRequest, grpc.ServerStreamingServer[Packet]) error {
	return status.Errorf(codes.Unimplemented, "method ListenPackets not implemented")
}
func (UnimplementedListenerServiceServer) ListenBytesPackets(*ListenBytesPacketsRequest, grpc.ServerStreamingServer[BytesPacket]) error {
	return status.Errorf(codes.Unimplemented, "method ListenBytesPackets not implemented")
}
func (UnimplementedListenerServiceServer) ListenTypedPacket(context.Context, *ListenTypedPacketRequest) (*response.GeneralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListenTypedPacket not implemented")
}
func (UnimplementedListenerServiceServer) ListenTypedBytesPacket(context.Context, *ListenTypedBytesPacketRequest) (*response.GeneralResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListenTypedBytesPacket not implemented")
}
func (UnimplementedListenerServiceServer) ListenPlayerChange(*ListenPlayerChangeRequest, grpc.ServerStreamingServer[PlayerAction]) error {
	return status.Errorf(codes.Unimplemented, "method ListenPlayerChange not implemented")
}
func (UnimplementedListenerServiceServer) ListenChat(*ListenChatRequest, grpc.ServerStreamingServer[Chat]) error {
	return status.Errorf(codes.Unimplemented, "method ListenChat not implemented")
}
func (UnimplementedListenerServiceServer) ListenCommandBlock(*ListenCommandBlockRequest, grpc.ServerStreamingServer[Chat]) error {
	return status.Errorf(codes.Unimplemented, "method ListenCommandBlock not implemented")
}
func (UnimplementedListenerServiceServer) mustEmbedUnimplementedListenerServiceServer() {}
func (UnimplementedListenerServiceServer) testEmbeddedByValue()                         {}

// UnsafeListenerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ListenerServiceServer will
// result in compilation errors.
type UnsafeListenerServiceServer interface {
	mustEmbedUnimplementedListenerServiceServer()
}

func RegisterListenerServiceServer(s grpc.ServiceRegistrar, srv ListenerServiceServer) {
	// If the following call pancis, it indicates UnimplementedListenerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ListenerService_ServiceDesc, srv)
}

func _ListenerService_ListenFateArk_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenFateArkRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ListenerServiceServer).ListenFateArk(m, &grpc.GenericServerStream[ListenFateArkRequest, Output]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenFateArkServer = grpc.ServerStreamingServer[Output]

func _ListenerService_ListenPackets_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenPacketsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ListenerServiceServer).ListenPackets(m, &grpc.GenericServerStream[ListenPacketsRequest, Packet]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenPacketsServer = grpc.ServerStreamingServer[Packet]

func _ListenerService_ListenBytesPackets_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenBytesPacketsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ListenerServiceServer).ListenBytesPackets(m, &grpc.GenericServerStream[ListenBytesPacketsRequest, BytesPacket]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenBytesPacketsServer = grpc.ServerStreamingServer[BytesPacket]

func _ListenerService_ListenTypedPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListenTypedPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerServiceServer).ListenTypedPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerService_ListenTypedPacket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerServiceServer).ListenTypedPacket(ctx, req.(*ListenTypedPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerService_ListenTypedBytesPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListenTypedBytesPacketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListenerServiceServer).ListenTypedBytesPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ListenerService_ListenTypedBytesPacket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListenerServiceServer).ListenTypedBytesPacket(ctx, req.(*ListenTypedBytesPacketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ListenerService_ListenPlayerChange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenPlayerChangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ListenerServiceServer).ListenPlayerChange(m, &grpc.GenericServerStream[ListenPlayerChangeRequest, PlayerAction]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenPlayerChangeServer = grpc.ServerStreamingServer[PlayerAction]

func _ListenerService_ListenChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ListenerServiceServer).ListenChat(m, &grpc.GenericServerStream[ListenChatRequest, Chat]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenChatServer = grpc.ServerStreamingServer[Chat]

func _ListenerService_ListenCommandBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenCommandBlockRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ListenerServiceServer).ListenCommandBlock(m, &grpc.GenericServerStream[ListenCommandBlockRequest, Chat]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ListenerService_ListenCommandBlockServer = grpc.ServerStreamingServer[Chat]

// ListenerService_ServiceDesc is the grpc.ServiceDesc for ListenerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ListenerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "fateark.proto.listener.ListenerService",
	HandlerType: (*ListenerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListenTypedPacket",
			Handler:    _ListenerService_ListenTypedPacket_Handler,
		},
		{
			MethodName: "ListenTypedBytesPacket",
			Handler:    _ListenerService_ListenTypedBytesPacket_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListenFateArk",
			Handler:       _ListenerService_ListenFateArk_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListenPackets",
			Handler:       _ListenerService_ListenPackets_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListenBytesPackets",
			Handler:       _ListenerService_ListenBytesPackets_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListenPlayerChange",
			Handler:       _ListenerService_ListenPlayerChange_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListenChat",
			Handler:       _ListenerService_ListenChat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListenCommandBlock",
			Handler:       _ListenerService_ListenCommandBlock_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/listener.proto",
}
